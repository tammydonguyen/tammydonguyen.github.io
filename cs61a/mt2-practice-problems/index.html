<!DOCTYPE html>
<html>
<title>MT2 Practice Problems</title>


<link rel="stylesheet" href="../../css/practice_problems.css">

<style>
li {
    font-weight: normal;
}
</style>

<xmp theme="journal" style="display:none;">
<div id="sidebar">
    <h3>Navigation</h3>
    <a href="#scope">Variable Scope</a> <br />
    <a href="#list-mut">List Mutability</a> <br />
    <a href="#link">Mutable Linked Lists</a> <br />
    <a href="#iter">Iterables and Iterators</a> <br />
    <a href="/cs61a/mt2-solutions">Solutions ></a> <br />
</div>

<a name="scope"></a>
## Variable Scope
    
    from operator import sub

    this = lambda a, b : lambda c: a(b, c)
    d = 30

    def that(e, f):
        if e and f:
            e, d = f(sub, e)(5), e
        else:
            print(e)
            d = 20
        def this(g):
           return lambda : print(g(d, e))
        return this

The code above is loaded into the Python interpreter. What would the following lines output? Assume they are entered one after the other in the same environment. If there is no output, leave the space blank. If the code causes an error, write Error and describe in a few words what caused it. 
   
    >>> this(sub, d)()
    
    >>> this(print, 40)(d)
    
    >>> this(lambda x, y : y, d)(20)
    
    >>> that(d, 0)(sub)

    >>> other = that(10, this)(print)
     
    >>> other() 


[SOLUTION](/cs61a/ppsolutions.html)

<a name="list-mut"></a> 
## List Mutability
Draw the environment diagram for the following code.  
    
    wow = [0, 'c', 's']

    def f(x):
        omg = []
        y = lambda : x - 5
        def g():
            nonlocal x
            while x > len(omg):
                x = y()
                omg.append(x)
            return omg[0:2]
        return g()

    lol = f(11)
    wow.extend(lol)
    lol = wow + ['a']
    wow = lol[1:]

[SOLUTION](/cs61a/ppsolutions.html#list-mut)

<a name="link"></a> 
## Mutable Linked Lists 
Implement `multiply`, which takes in a Linked List and mutates it so that each link is duplicated by the amount of its entry. See the doctests for examples.

    def multiply(link):
        """ 
        >>> link = Link(2, Link(3))
        >>> multiply(link)
        >>> link
        Link(2, Link(2, Link(3, Link(3, Link(3)))))
        >>> link = Link(4, Link(1, Link(2)))
        >>> multiply(link)
        >>> link
        Link(4, Link(4, Link(4, Link(4, Link(1, Link(2, Link(2)))))))
        """

[SOLUTION](/cs61a/ppsolutions.html#link)

<a name="iter"></a>   
  

## Iterables and Iterators
### Concepts
<ol>
<li>What method(s) must **iterables** have?
<li>What method(s) must **iterators** have?
<li>What data type does `__iter__` return?
<li>What data type does `__next__` return?
<li>Is a **generator** an iterable or an iterator?
<li>What keyword in the body of a function makes that function return a generator object?
<li>How is `yield` different from `return`?
<li>When you call `next` on a generator, the body starts executing at what line? At what line will it stop? At what line will it start the next time you call `next`?
<li>What happens when you call `list` on an iterable or an iterator? What happens if you call it a second time on the same objects?
<li>Can you iterate through an iterable in a for loop? Can you iterate through an iterator in a for loop?
</ol>

### What would Python print?
The following classes define an iterable representing the sequence of multiples for any given number and the iterator that returns the next value in the sequence. The sequence goes up to 1000.

    class Multiples:
        def __init__(self, num):
            self.num = num
        
        def __iter__(self):
            return MultiplesIterator(self.num)
    
    class MultiplesIterator:
        def __init__(self, num):
            self.num = num
            self.curr = num
        
        def __iter__(self):
            return self
        
        def __next__(self):
            if self.curr >= 1000:
                raise StopIteration
            val = self.curr
            self.curr = self.curr * self.num
            return val
            
What will the following lines output?

    >>> hundreds = Multiples(100)
    >>> next(hundreds)

    >>> next(iter(hundreds))

    >>> next(iter(hundreds))

    >>> i = iter(hundreds)

    >>> i is iter(hundreds)

    >>> i is iter(i)

    >>> next(i)

    >>> next(i)

    >>> list(m)

    >>> list(i)

    >>> list(m)

    >>> list(i)

    >>> for i in m:
    ...     print(i)

    >>> for x in i:
    ...     print(x)
        

### Writing functions
1. Fill in the following definition of a generator function which yields every number from `1` to `n` and prints `m was a factor` if the previous number, `m`, was a factor of `n`. See the doctests for an example.
  
        def print_factor(n):
            """
            >>> gen = print_factor(8)
            >>> next(gen)
            1
            >>> next(gen)
            1 was a factor
            2
            >>> next(gen)
            2 was a factor
            3
            >>> next(gen)
            4
            >>> next(gen)
            4 was a factor
            5
            """
            "*** YOUR CODE HERE ***"

2. Implement `mimic_list` so that it behaves like Python's built-in `list` constructor. See WWPP answers for examples of the behavior.

        def mimic_list(iterable):
            "*** YOUR CODE HERE ***"

3. Recall that all `__iter__` methods must return an iterator type. Well, a generator *is* an iterator, so you can write `__iter__` to be a generator function! Write the `__iter__` method for BinaryTree such that it returns a generator. Calling `next` on this generator will return the elements of the BinaryTree in ascending order. Assume that all instances of BinaryTree fall under the constraints of a binary *search* tree: 
    * the root entry is greater than or equal to all entries in the left side of the BinaryTree
    * the root entry is lses than or equal to all entries in the right side of the BinaryTree  

            class BinarySearchTree:
                empty = ()

                def __init__(self, entry, left=empty, right=empty):
                    self.entry = entry
                    if left: assert isinstance(left, BinaryTree) 
                    if right: assert isinstance(right, BinaryTree)
                    self.left = left
                    self.right = right

                def __iter__(self):
                    """
                    >>> tree = BinaryTree(4, BinaryTree(2), BinaryTree(7, BinaryTree(5)))
                    >>> for entry in tree:
                    ...     print(entry)
                    2
                    4
                    5
                    7
                    """
                    "*** YOUR CODE HERE ***"

[SOLUTIONS](/cs61a/ppsolutions.html#iter)

</xmp>

<script src="http://strapdownjs.com/v/0.2/strapdown.js"></script>
</html>
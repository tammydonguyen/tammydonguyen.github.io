<!DOCTYPE html>
<html>
<title>Scheme</title>

<link href="../../css/bootstrap.min.css" rel="stylesheet">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<link href="../../css/guides.css" rel="stylesheet"></link>
<script src="../../js/slidin.js"></script>

<body>
<nav class="navbar navbar-default navbar-fixed-top">
<div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <h3>Scheme</h3>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <!-- stuff next to header -->
      </ul>
      
      <ul class="nav navbar-nav navbar-right">
        <li><a href="/cs61a/resources.html">Resources</a></li>
        <li class="dropdown active">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Guides</a>
          <ul class="dropdown-menu" role="menu">
            <li><a href="/cs61a/guides/env-diag.html">Env. Diagrams</a></li>
            <li><a href="/cs61a/guides/recursion.html">Recursion</a></li>
            <li><a href="/cs61a/guides/oop.html">OOP</a></li>
            <li><a href="#">Scheme</a></li>
            <li><a href="/cs61a/guides/tail-recursion.html">Tail Recursion</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Practice Problems</a>
          <ul class="dropdown-menu" role="menu">
            <li><a href="/cs61a/practice-problems/iter.html">Iterators</a></li>
            <li><a href="/cs61a/practice-problems/scheme.html">Scheme</a></li>
            <li><a href="/cs61a/practice-problems/mt2.html">Midterm 2</a></li>
            <li><a href="/cs61a/practice-problems/final.html">Final</a></li>
          </ul>
        </li>
        <li><a href="/"><span class="glyphicon glyphicon-home"></span></a></li>
      </ul>
    </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</nav>
</body>

<xmp theme="journal" style="display:none;">
<br />
**This page is under construction!**

----
## Intro  
Scheme, a dialect of another language called Lisp, is a very powerful functional programming language. In this class, we are only concerned with a very basic subset of the Scheme language which includes writing basic procedures, manipulating pairs and lists, writing tail recursive procedures, and working with streams. 

This guide assumes you know basic scheme, including primitives, variable and procedure definitions, and call expressions. For a quick review, what would Scheme output after each of the following lines are input? 

<pre><code>scm> (define x 3)  
<span class="solution">x</span>
scm> (define y (+ 10 x))  
<span class="solution">y</span>
scm> y
<span class="solution">13</span>
scm> (define (foo x y)  
		(cond ((> x y) 1)
			  ((< x y) -1)
			  (else 0)))
<span class="solution">foo</span>
scm> 'foo
<span class="solution">foo</span>
scm> (eval '(foo y x))
<span class="solution">1</span>
scm> ((lambda (x y) (if (< x y) 'less-than 'greater-than)) y x)
<span class="solution">greater-than</span>
scm> '(a b c)
<span class="solution">(a b c)</span></code></pre>

<a class="btn btn-default solution-toggle">TOGGLE SOLUTION</a>

If you had any trouble with this, take time to review the [Scheme lab](http://cs61a.org/lab/lab11/).

## Lists
Lists in Scheme are a lot like Linked Lists in Python. Whereas a Linked List in Python is comprised of several `Link`s, a list in Scheme is made up of pairs.

#### Pairs
A pair is the fundamental sequential unit in Scheme. To create one, use `cons`. `cons` takes in two arguments and creates a pair out of them.

    scm> (cons 3 5)
    (3 . 5)

The elements in a pair are separated by a dot. To retrieve the first element, use `car`. To retrieve the second element, use `cdr`.

	scm> (define lst (cons 2 3))
	lst
	scm> (car lst)
	2
	scm> (cdr (cons 4 5))
	5

The entries in a pair can be other pairs. 

	scm> (define lst (cons 3 (cons 4 5)))
	lst
	scm> lst
	(3 4 . 5)
	scm> (car lst)
	3
	scm> (cdr lst)
	(4 . 5)
	scm> (cdr (cdr lst))
	5
    scm> (cons (cons 4 5) (cons 6 7))
    ((4 . 5) 6 . 7)

When Scheme sees a `.` immediately followed by an open parenthesis, it removes the dot, the open parenthesis, *and* the corresponding close parenthesis. This way, we can construct what's known as a **well-formed list** from a bunch of pairs!  

#### Well-formed lists
A well-formed list is actually just a pair whose first argument is the first element of the list and the second argument is another well-formed list. The last list argument is an empty list, or `nil`, to signify the end of the sequence.

	scm> (cons 5 nil) ; one-element list
	(5)
	scm> (cons 1 (cons 2 (cons 3 nil))) ; three-element list
	(1 2 3)
	scm> (cons 1 (cons 2 (cons 3 '()))) ; same as previous
	(1 2 3)

The take-away is this: `cons` can be used to create a list if and only if the first arugument is the first element of the list and the second argument is another list, which can be `nil`.

	scm> (define first 1)
	first
	scm> (define rest '(2 3 4 5)) 
	rest
	scm> (cons first rest)
	(1 2 3 4 5)

Notice above that it is possible to also create lists with `'`. Keep in mind that this will create the exact list that comes after it, which means we can't do something like `'(1 (cons 2 nil))`.   

Scheme provides us with an alternate to `cons` that is much more succinct and readable: `list`. `list` takes in an arbitrary number of arguments and will simply create a well formed list of them.

	scm> (list 1 2 3 4)
	(1 2 3 4)

Be careful, though; whereas with `cons` you can pass through the rest of the list as the second argument, passing lists through to `list` will create nested lists!

	scm> (list 1 2 (list 3 4) 5)
	(1 2 (3 4) 5)
	scm> (list 1 2 (cons 3 (cons 4 nil)) 5)
	(1 2 (3 4) 5)

You can check whether a list is empty using `(null? lst)`. This is like asking whether `(= lst nil)`.

    scm> (null? nil)
    True
    scm> (null? (list 1 2 3))
    False
    scm> (null? '())
    True

>**Summary**  
1. A list is a pair whose second entry is another list.  
2. To construct a pair, use `cons`.  
3. To construct a list using `cons`, pass through its first element as the first argument and the rest of the list as the second argument.
4. To construct a list using `list`, pass through every element in the list.  
5. To retrieve the first element of a pair or list, call `car`.   
6. To retrieve the second element of a pair or the rest of a list, call `cdr`.  7. Check whether a list is empty using the predicate `null?`.

<a class="btn btn-default" href="/cs61a/practice-problems/scheme.html#lists">basic problems</a>&nbsp;&nbsp;
<a class="btn btn-default" href="/cs61a/practice-problems/final.html#scheme-lists">exam-level problems</a>
</xmp>

<script src="http://strapdownjs.com/v/0.2/strapdown.js"></script>
<link href="../../css/lumen.css" rel="stylesheet">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="../../js/bootstrap.min.js"></script>

<style>
.navbar .nav>li>.dropdown-menu:before, .navbar .nav>li>.dropdown-menu:after {
    margin-left: 70%;
}
</style>

</html>
<!DOCTYPE html>
<html>
<title>Scheme</title>

<link href="../../css/bootstrap.min.css" rel="stylesheet">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<link href="../../css/guides.css" rel="stylesheet"></link>
<script src="../../js/slidin.js"></script>

<body>
<nav class="navbar navbar-default navbar-fixed-top">
<div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <h3>Scheme</h3>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <!-- stuff next to header -->
      </ul>
      
      <ul class="nav navbar-nav navbar-right">
        <li><a href="/cs61a/resources.html">Resources</a></li>
        <li class="dropdown active">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Guides</a>
          <ul class="dropdown-menu" role="menu">
            <li><a href="/cs61a/guides/env-diag.html">Env. Diagrams</a></li>
            <li><a href="/cs61a/guides/recursion.html">Recursion</a></li>
            <li><a href="/cs61a/guides/oop.html">OOP</a></li>
            <li><a href="#">Scheme</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Practice Problems</a>
          <ul class="dropdown-menu" role="menu">
            <li><a href="/cs61a/practice-problems/iter.html">Iterators</a></li>
            <li><a href="/cs61a/practice-problems/scheme.html">Scheme</a></li>
            <li><a href="/cs61a/practice-problems/mt2.html">Midterm 2</a></li>
            <li><a href="/cs61a/practice-problems/final.html">Final</a></li>
          </ul>
        </li>
        <li><a href="/"><span class="glyphicon glyphicon-home"></span></a></li>
      </ul>
    </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</nav>
</body>

<xmp theme="journal" style="display:none;">
<br />
**This page is under construction!**

----
## Intro  
Scheme, a dialect of another language called Lisp, is a very powerful functional programming language. In this class, we are only concerned with a very basic subset of the Scheme language which includes writing basic procedures, manipulating pairs and lists, writing tail recursive procedures, and working with streams. 

This guide assumes you know basic scheme, including primitives, variable and procedure definitions, and call expressions. For a quick review, what would Scheme output after each of the following lines are input? 

<pre><code>scm> (define x 3)  
<span class="solution">x</span>
scm> (define y (+ 10 x))  
<span class="solution">y</span>
scm> y
<span class="solution">13</span>
scm> (define (foo x y)  
		(cond ((> x y) 1)
			  ((< x y) -1)
			  (else 0)))
<span class="solution">foo</span>
scm> 'foo
<span class="solution">foo</span>
scm> (eval '(foo y x))
<span class="solution">1</span>
scm> ((lambda (x y) (if (< x y) 'less-than 'greater-than)) y x)
<span class="solution">greater-than</span>
scm> '(a b c)
<span class="solution">(a b c)</span></code></pre>

<a class="btn btn-default solution-toggle">TOGGLE SOLUTION</a>

If you had any trouble with this, take time to review the [Scheme lab](http://cs61a.org/lab/lab11/).

## Lists
Lists in Scheme are a lot like Linked Lists in Python. Whereas a Linked List in Python is comprised of several `Link`s, a list in Scheme is made up of pairs.

#### Pairs
A pair is the fundamental sequential unit in Scheme. To create one, use `cons`. `cons` takes in two arguments and creates a pair out of them.

    scm> (cons 3 5)
    (3 . 5)

The elements in a pair are separated by a dot. To retrieve the first element, use `car`. To retrieve the second element, use `cdr`.

	scm> (define lst (cons 2 3))
	lst
	scm> (car lst)
	2
	scm> (cdr (cons 4 5))
	5

The entries in a pair can be other pairs. 

	scm> (define lst (cons 3 (cons 4 5)))
	lst
	scm> lst
	(3 4 . 5)
	scm> (car lst)
	3
	scm> (cdr lst)
	(4 . 5)
	scm> (cdr (cdr lst))
	5
    scm> (cons (cons 4 5) (cons 6 7))
    ((4 . 5) 6 . 7)

When Scheme sees a `.` immediately followed by an open parenthesis, it removes the dot, the open parenthesis, *and* the corresponding close parenthesis. This way, we can construct what's known as a **well-formed list** from a bunch of pairs!  

#### Well-formed lists
A well-formed list is actually just a pair whose first argument is the first element of the list and the second argument is another well-formed list. The last list argument is an empty list, or `nil`, to signify the end of the sequence.

	scm> (cons 5 nil) ; one-element list
	(5)
	scm> (cons 1 (cons 2 (cons 3 nil))) ; three-element list
	(1 2 3)
	scm> (cons 1 (cons 2 (cons 3 '()))) ; same as previous
	(1 2 3)

The take-away is this: `cons` can be used to create a list if and only if the first arugument is the first element of the list and the second argument is another list, which can be `nil`.

	scm> (define first 1)
	first
	scm> (define rest '(2 3 4 5)) 
	rest
	scm> (cons first rest)
	(1 2 3 4 5)

Notice above that it is possible to also create lists with `'`. Keep in mind that this will create the exact list that comes after it, which means we can't do something like `'(1 (cons 2 nil))`.   

Scheme provides us with an alternate to `cons` that is much more succinct and readable: `list`. `list` takes in an arbitrary number of arguments and will simply create a well formed list of them.

	scm> (list 1 2 3 4)
	(1 2 3 4)

Be careful, though; whereas with `cons` you can pass through the rest of the list as the second argument, passing lists through to `list` will create nested lists!

	scm> (list 1 2 (list 3 4) 5)
	(1 2 (3 4) 5)
	scm> (list 1 2 (cons 3 (cons 4 nil)) 5)
	(1 2 (3 4) 5)

You can check whether a list is empty using `(null? lst)`. This is like asking whether `(= lst nil)`.

    scm> (null? nil)
    True
    scm> (null? (list 1 2 3))
    False
    scm> (null? '())
    True

>**Summary**  
1. A list is a pair whose second entry is another list.  
2. To construct a pair, use `cons`.  
3. To construct a list using `cons`, pass through its first element as the first argument and the rest of the list as the second argument.
4. To construct a list using `list`, pass through every element in the list.  
5. To retrieve the first element of a pair or list, call `car`.   
6. To retrieve the second element of a pair or the rest of a list, call `cdr`.  7. Check whether a list is empty using the predicate `null?`.

<a class="btn btn-default" href="/cs61a/practice-problems/scheme.html#lists">basic problems</a>&nbsp;&nbsp;
<a class="btn btn-default" href="/cs61a/practice-problems/final.html#scheme-lists">exam-level problems</a>

## Tail Recursion
Scheme supports optimized tail recursion, meaning that if a function is called in **tail context**, Scheme will close the frame that called it and simply return the value that the tail call returns. Scheme thus allows for an unbounded number of tail calls, unlike Python, which will raise a `RuntimeError: 'maximum recursion depth exceeded'` because all the frames stay open. 

#### Tail Context 
An expression is in a **tail context** if it is the last expression to be evaluated in the frame. Thus, a call expression is a **tail call** if it is one of the following:  

* the last sub-expression in the body of a tail-context `lambda` expression
* the second or third sub-expression in a tail-context `if` expression
* a non-predicate sub-expression in a tail-context `cond` expression
* the last sub-expression in a tail-context `and` or `or` expression
* the last sub-expression in a tail-context `begin` expression

A function is then **tail recursive** if the recursive call(s) is a/are tail call(s).

##### Test your understanding
**Answer these questions for the following functions.**  
1. What are the tail calls?  
2. Are the recursive calls tail calls?  
3. Is the function tail recursive?  
    
    (define (foo x y)
    	(if (> x y) 
    		(foo (- x y)) 
    		(+ x y)))

<span class="solution">1. `(foo (- x y))` is a tail call because it is the second subexpression in the `if` expresssion. `(+ x y)` is also a tail call because it is the third subexpression in the `if` expression.  
2. Yes, the recursive call `(foo (- x y))` is a tail call.  
3. Yes, because the recursive call is a tail call. </span>
<a class="btn btn-default solution-toggle">toggle solution</a>

    (define (bar x)
    	(if (bar x) x
    		(- (bar 9) 1))

<span class="solution-2">1. `(- (bar 9) 1)` is a tail call because it is the third subexpression in the `if` expresssion.  
2. The recursive calls `(bar x)` is not a tail call because it is the first subexpression in the `if` expression. The recursive call `(bar 9)` is also not a tail call because it is an argument of the tail call.  
3. No, because the recursive calls are not tail calls.</span>
<a class="btn btn-default solution-toggle-2">toggle solution</a>

    (define (baz x)
    	(cond ((bar x) (begin (foo x x) (baz (+ x x))))
            ((baz 1) (baz 2))
            (else (and (foo x 1) #t (bar 4))))
          )

<span class="solution-3">1. `(baz (+ x x))` is a tail call because it is the last subexpression in a tail-context `begin` expression. `(baz 2)` is a tail call because it is a non-predicate subexpression in the `cond` expression. `(bar 4)` is a tail call because it is the last subexpression in a tail-context `and` expression.  
2. Two of the tail calls mentioned above are recursive calls. The recursive call `(baz 1)` is not a tail call because it is a predicate subexpression in the `cond` expression.  
3. No, even though there are two recursive tail calls, there is a recursive call that is not a tail call.</span>
<a class="btn btn-default solution-toggle-3">toggle solution</a>

## Writing tail recursive functions
Often, you may find it easier to first come up with an iterative solution in Python and convert it into a tail recursive Scheme solution. For example, let's try to write a function that makes a list out of the first `n` elements of a given `lst` (assume `lst` is at least length `n`).  

To do this, we would start with an empty `result` list and keep a counter, adding elements to `result` from `lst` until our counter hits `n`. Here's the iterative Python version for a linked list:  
    
    def keep_first_n(link, n):
        i, result = 0, Link.empty
        while i < n:
            result = Link(link.first, result)
            link = link.rest
            i += 1
        return result

Since there are no `while` loops in Scheme, we can imitate this using a helper function! A helper function will keep track of variables that change in its parameters! In this case, the counter `i`, our `result` list, and the link pointer change, so our helper function will take in three parameters `i`, `result`, and `lst`.
    
    (define (keep-first-n lst n)
      (define (keep-helper i result lst)

        ))

To simulate the `while` condition, we use a base case to return our result when we're done. We want to stop adding to `result` and return it when `i` is equal to `n`. Whatever happens in the while loop will go in the "else" case.
  
    (define (keep-first-n lst n)
      (define (keep-helper i result)
          (if (= i n) result)
        ))

So far, so good. Now we need to take care of what goes on in the `while` loop, which is updating `result`, `lst`, and `i`. Using recursion, we simply update our "variables" by passing their new values as arguments to a recursive call.

    (define (keep-first-n lst n)
      (define (keep-helper i result)
          (if (= i n) result
            (keep-helper (+ i 1) (append result (list (car lst))) (cdr lst)))
        ))

Almost done! All that's left to do now is initialize our "variables". To do this, call our helper function in the body of the original function with the initial values as arguments.

    (define (keep-first-n lst n)
      (define (helper i result lst)
          (if (= i n) result
            (helper (+ i 1) (append result (list (car lst))) (cdr lst)))
        )
      (helper 0 '() lst))

This function is now a tail-recursive version of the iterative solution!

</xmp>

<script src="http://strapdownjs.com/v/0.2/strapdown.js"></script>
<link href="../../css/lumen.css" rel="stylesheet">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="../../js/bootstrap.min.js"></script>

<style>
.navbar .nav>li>.dropdown-menu:before, .navbar .nav>li>.dropdown-menu:after {
    margin-left: 70%;
}
</style>

</html>
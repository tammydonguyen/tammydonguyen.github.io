<!DOCTYPE html>
<html>
<title>MT2 Practice Problems</title>

<link rel="stylesheet" href="../../css/practice_problems.css">
<link href="../../css/lumen.min.css" rel="stylesheet">

<body>
<nav class="navbar navbar-default navbar-fixed-top">
<div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <h3>CS61A Resources</h3>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <!-- stuff next to header -->
      </ul>
      
      <ul class="nav navbar-nav navbar-right">
        <li><a href="/cs61a/resources.html">Resources</a></li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Guides</a>
          <ul class="dropdown-menu" role="menu">
            <li><a href="/cs61a/guides/env-diag.html">Env. Diagrams</a></li>
            <li><a href="/cs61a/guides/recursion.html">Recursion</a></li>
            <li><a href="/cs61a/guides/oop.html">OOP</a></li>
            <li><a href="/cs61a/guides/scheme.html">Scheme</a></li>
          </ul>
        </li>
        <li class="dropdown active">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Practice Problems</a>
          <ul class="dropdown-menu" role="menu">
            <li><a href="#">Midterm 2</a></li>
            <li><a href="/cs61a/practice-problems/final.html">Final</a></li>
          </ul>
        </li>
        <li><a href="/"><span class="glyphicon glyphicon-home"></span></a></li>
      </ul>
    </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</nav>
</body>

<xmp theme="journal" style="display:none;">
<div id="sidebar">
    <h3>Navigation</h3>
    <a href="#scope">Variable Scope</a> <br />
    <a href="#list-mut">List Mutability</a> <br />
    <a href="#link">Mutable Linked Lists</a> <br />
    <a href="#iter">Iterables and Iterators</a> <br />
</div>

<a name="scope"></a>
## Variable Scope
    
    from operator import sub

    this = lambda a, b : lambda c: a(b, c)
    d = 30

    def that(e, f):
        if e and f:
            e, d = f(sub, e)(5), e
        else:
            print(e)
            d = 20
        def this(g):
           return lambda : print(g(d, e))
        return this

The code above is loaded into the Python interpreter. What would the following lines output? Assume they are entered one after the other in the same environment. If there is no output, leave the space blank. If the code causes an error, write Error and describe in a few words what caused it. 
   
<pre><code>>>> this(sub, d)()
<span class="solution">Error, second function call missing an argument</span>
>>> this(print, 40)(d)
<span class="solution">40 30</span>
>>> this(lambda x, y : y, d)(20)
<span class="solution">20</span>
>>> that(d, 0)(sub)
<span class="solution">30<br><\function ...></span>
>>> other = that(10, this)(print)
<span class="solution"></span>
>>> other() 
<span class="solution">10 5<br>None</span></code></pre>

<a class="solution-toggle btn btn-default">TOGGLE SOLUTION</a>

<a name="list-mut"></a> 
## List Mutability
Draw the environment diagram for the following code.  
    
    wow = [0, 'c', 's']

    def f(x):
        omg = []
        y = lambda : x - 5
        def g():
            nonlocal x
            while x > len(omg):
                x = y()
                omg.append(x)
            return omg[0:2]
        return g()

    lol = f(11)
    wow.extend(lol)
    lol = wow + ['a']
    wow = lol[1:]

<div class="solution-2">
<iframe width="650" height="400" frameborder="0" src="http://pythontutor.com/iframe-embed.html#code=wow+%3D+%5B0,+'c',+'s'%5D%0A%0Adef+f(x%29%3A%0A++++omg+%3D+%5B%5D%0A++++y+%3D+lambda+%3A+x+-+5%0A++++def+g(%29%3A%0A++++++++nonlocal+x%0A++++++++while+x+%3E+len(omg%29%3A%0A++++++++++++x+%3D+y(%29%0A++++++++++++omg.append(x%29%0A++++++++return+omg%5B0%3A2%5D%0A++++return+g(%29%0A%0Alol+%3D+f(11%29%0Awow.extend(lol%29%0Alol+%3D+wow+%2B+%5B'a'%5D%0Awow+%3D+lol%5B1%3A%5D&origin=opt-frontend.js&cumulative=true&heapPrimitives=false&textReferences=false&py=3&rawInputLstJSON=%5B%5D&curInstr=0&codeDivWidth=350&codeDivHeight=300"> </iframe>
</div>
<a class="solution-toggle-2 btn btn-default">TOGGLE SOLUTION</a>

<a name="link"></a> 
## Mutable Linked Lists 
Implement `multiply`, which takes in a Linked List and mutates it so that each link is duplicated by the amount of its entry. See the doctests for examples.

<pre><code>def multiply(link):
    """ 
    >>> link = Link(2, Link(3))
    >>> multiply(link)
    >>> link
    Link(2, Link(2, Link(3, Link(3, Link(3)))))
    >>> link = Link(4, Link(1, Link(2)))
    >>> multiply(link)
    >>> link
    Link(4, Link(4, Link(4, Link(4, Link(1, Link(2, Link(2)))))))
    """
    <span class="solution-prompt">"*** YOUR CODE HERE ***"</span>
    <span class="solution-p">def helper(link, count):
        if count == 1 and link.rest != Link.empty:
            multiply(link.rest)
        elif count != 1 and link != Link.empty:
            link.rest = Link(link.first, link.rest)
            helper(link.rest, count - 1)
    helper(link, link.first)</span></code></pre>

<a class="solution-toggle-p btn btn-default">TOGGLE SOLUTION</a>

<a name="iter"></a>   
  

## Iterables and Iterators
### Concepts
<ol>
<li> What method(s) must **iterables** have?   </li>
<span class="solution-4"><b>`__iter__`</b></span>
<li>What method(s) must **iterators** have?  </li>
<span class="solution-4"><b>`__iter__` AND `__next__`</b></span>
<li>What data type does `__iter__` return? </li>
<span class="solution-4"><b>iterator</b></span>
<li>What data type does `__next__` return?</li>
<span class="solution-4"><b>whatever type each element of the sequence is</b></span>
<li>Is a **generator** an iterable or an iterator?  </li>
<span class="solution-4"><b>iterator</b></span>
<li>What keyword in the body of a function makes that function return a generator object?  </li>
<span class="solution-4"><b>`yield`</b></span>
<li>How is `yield` different from `return`?    </li>
<span class="solution-4"><b>`yield` does not close the frame. `yield` outputs a value, and keeps the frame open until `StopIteration` is raised.</b></span>
<li>When you call `next` on a generator, the body starts executing at what line? At what line will it stop? At what line will it start the next time you call `next`?  </li>
<span class="solution-4"><b>execution starts at the first line of the body and stops after the line with `yield` is executed. when `next` is called again, execution picks up at the line right after the `yield` statement (where it last left off) and stops after another `yield` execution *or* if there are no more lines in the body.</b></span>
<li>What happens when you call `list` on an iterable or an iterator? What happens if you call it a second time on the same objects?  </li>
<span class="solution-4"><b>when you call `list` on an iterable or an iterator, Python calls `iter` on it and then attempts to construct a list with the `next` element until `StopIteration` is reached, then returns the constructed list.</b></span>
<li>Can you iterate through an iterable in a for loop? Can you iterate through an iterator in a for loop?  </li>
<span class="solution-4"><b>you can use both iterables and iterators in a for loop.</b></span>
</ol>

<a class="solution-toggle-4 btn btn-default">TOGGLE SOLUTION</a>

### What would Python print?
The following classes define an iterable representing the sequence of multiples for any given number and the iterator that returns the next value in the sequence. The sequence goes up to 1000.

    class Multiples:
        def __init__(self, num):
            self.num = num
        
        def __iter__(self):
            return MultiplesIterator(self.num)
    
    class MultiplesIterator:
        def __init__(self, num):
            self.num = num
            self.curr = num
        
        def __iter__(self):
            return self
        
        def __next__(self):
            if self.curr >= 1000:
                raise StopIteration
            val = self.curr
            self.curr = self.curr * self.num
            return val
            
What will the following lines output?

<pre><code>>>> hundreds = Multiples(100)<br>>>> next(hundreds)
<span class="solution-3">TypeError: 'Multiples' object is not an iterator</span>
>>> next(iter(hundreds))
<span class="solution-3">100</span>
>>> next(iter(hundreds))
<span class="solution-3">100</span>
>>> i = iter(hundreds)
>>> i is iter(hundreds)
<span class="solution-3">False</span>
>>> i is iter(i)
<span class="solution-3">True</span>
>>> next(i)
<span class="solution-3">100</span>
>>> next(i)
<span class="solution-3">200</span>
>>> list(m)
<span class="solution-3">[100, 200, 300, 400, 500, 600, 700, 800, 900]</span>
>>> list(i)
<span class="solution-3">[300, 400, 500, 600, 700, 800, 900]</span>
>>> list(m)
<span class="solution-3">[100, 200, 300, 400, 500, 600, 700, 800, 900]</span>
>>> list(i)
<span class="solution-3">[]</span>
>>> for i in m:
...     print(i)
<span class="solution-3">5<br>25<br>125<br>625</span>
>>> for x in i:
...     print(x)</code></pre>

<span class="solution-3">**Explanation**: `Multiples`'s `__iter__` method always returns a *new instance* of `MultiplesIterator`, whereas `MultiplesIterator`'s `__iter__` simply returns itself. For iterables, calling `iter` will reset the iterator, but since iterators just return themselves, they do not reset.</span>

<a class="solution-toggle-3 btn btn-default">TOGGLE SOLUTION</a>

### Writing functions
Fill in the following definition of a generator function which yields every number from `1` to `n` and prints `'m was a factor'` if the previous number, `m`, was a factor of `n`. See the doctests for an example.
  
<pre><code>def print_factor(n):
    """
    >>> gen = print_factor(8)
    >>> next(gen)
    1
    >>> next(gen)
    1 was a factor
    2
    >>> next(gen)
    2 was a factor
    3
    >>> next(gen)
    4
    >>> next(gen)
    4 was a factor
    5
    """
    <span class="solution-2-prompt">"*** YOUR CODE HERE ***"</span>
    <span class="solution-2-p">curr = 1
while curr <= n:
    if n % curr == 0:
        print('factor!')
    yield curr
    curr += 1</span></code></pre>

<a class="solution-toggle-2-p btn btn-default">TOGGLE SOLUTION</a>

Implement `mimic_list` so that it behaves like Python's built-in `list` constructor. See WWPP answers for examples of the behavior.

<pre><code>def mimic_list(iterable):
    """ mimics the behavior of the built-in list constructor """
    <span class="solution-3-prompt">"*** YOUR CODE HERE ***"</span>
    <span class="solution-3-p">i = iter(iterable) # get iterable's iterator object
lst = []  # create an empty list
try:
    while True:   # add every elem in sequence to lst
        curr = next(i)
        lst.append(curr)
except StopIteration as e: # return lst when the sequence is done
    return lst  </span></code></pre>

<a class="solution-toggle-3-p btn btn-default">TOGGLE SOLUTION</a>

Recall that all `__iter__` methods must return an iterator type. Well, a generator *is* an iterator, so you can write `__iter__` to be a generator function! Write the `__iter__` method for BinaryTree such that it returns a generator. Calling `next` on this generator will return the elements of the BinaryTree in ascending order. Assume that all instances of BinaryTree fall under the constraints of a binary *search* tree: 
    * the root entry is greater than or equal to all entries in the left side of the BinaryTree
    * the root entry is lses than or equal to all entries in the right side of the BinaryTree  

<pre><code>class BinarySearchTree:
    empty = ()

    def __init__(self, entry, left=empty, right=empty):
        self.entry = entry
        if left: assert isinstance(left, BinaryTree) 
        if right: assert isinstance(right, BinaryTree)
        self.left = left
        self.right = right

    def __iter__(self):
        """
        >>> tree = BinaryTree(4, BinaryTree(2), BinaryTree(7, BinaryTree(5)))
        >>> for entry in tree:
        ...     print(entry)
        2
        4
        5
        7
        """
        <span class="solution-4-prompt">"*** YOUR CODE HERE ***"</span>
    <span class="solution-4-p">    for value in self.left:
        yield value

    yield self.entry

    for value in self.right:
        yield value</span></code></pre>

<a class="solution-toggle-4-p btn btn-default">TOGGLE SOLUTION</a>

</xmp>

<script src="http://strapdownjs.com/v/0.2/strapdown.js"></script>
<link href="../../css/lumen.min.css" rel="stylesheet">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="../../js/bootstrap.min.js"></script>

<style>
.navbar .nav>li>.dropdown-menu:before, .navbar .nav>li>.dropdown-menu:after {
    margin-left: 70%;
}
</style>
</html>
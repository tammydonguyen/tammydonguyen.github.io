<!DOCTYPE html>
<html>
<title>Final Practice Problems</title>

<link rel="stylesheet" href="../../css/practice_problems.css">
<link href="../../css/bootstrap.min.css" rel="stylesheet">
<link href="../../css/lumen.min.css" rel="stylesheet">

<body>
<nav class="navbar navbar-default navbar-fixed-top">
<div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <h3>Final Practice Problems</h3>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <!-- stuff next to header -->
      </ul>
      
      <ul class="nav navbar-nav navbar-right">
        <li><a href="/cs61a/resources.html">Resources</a></li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Guides</a>
          <ul class="dropdown-menu" role="menu">
            <li><a href="/cs61a/guides/env-diag.html">Env. Diagrams</a></li>
            <li><a href="/cs61a/guides/recursion.html">Recursion</a></li>
            <li><a href="/cs61a/guides/oop.html">OOP</a></li>
            <li><a href="/cs61a/guides/scheme.html">Scheme</a></li>
            <li><a href="/cs61a/guides/tail-recursion.html">Tail Recursion</a></li>
          </ul>
        </li>
        <li class="dropdown active">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Practice Problems</a>
          <ul class="dropdown-menu" role="menu">
            <li><a href="/cs61a/practice-problems/iter.html">Iterators</a></li>
            <li><a href="/cs61a/practice-problems/scheme.html">Scheme</a></li>
            <li><a href="/cs61a/practice-problems/mt2.html">Midterm 2</a></li>
            <li><a href="#">Final</a></li>
          </ul>
        </li>
        <li><a href="/"><span class="glyphicon glyphicon-home"></span></a></li>
      </ul>
    </div><!-- /.navbar-collapse -->
</div><!-- /.container-fluid -->
</nav>
</body>

<xmp theme="journal" style="display:none;">
<div id="sidebar" style="margin-top: -10px">
    <h3>Navigation</h3>
    <a href="#scheme-lists">Scheme Lists</a> <br />
    <a href="#tail">Tail Recursion</a> <br />
    <a href="#stream">Streams</a> <br />
    <a href="#sql">SQL</a> <br />
    <a href="#logic">Logic</a> <br />
</div>
<br>
**This page is under construction!**

---

<p>These problems are designed to be around exam difficulty. For more basic problems, see the topic-based guides and practice problems!</p>

---

<a name="scheme-lists" class="anchor"></a>
## Scheme Lists
Write a function `non-contiguous` that checks whether `subseq` is a non-contiguous subsequence of `lst`. A sequence is a non-contiguous subsequence if its elements appear in the list in order but not necessarily immediately next to each other.

    scm> (non-contiguous '() lst)
    True
    scm> (non-contiguous '(1 3 6) '(1 2 3 4 5 6))
    True
    scm> (non-contiguous '(1 5 2) '(1 2 3 4 5 6))
    False

<pre><code>(define (non-contiguous subseq lst)
<span class="solution-2-prompt">  "YOUR CODE HERE"
)</span>
<span class="solution-2-p">  (cond ((null? subseq) #t)
        ((null? lst) #f)
        ((= (car subseq) (car lst)) (non-contiguous (cdr subseq) (cdr lst)))
        (else (non-contiguous subseq (cdr lst))))
)</span></code></pre>
<a class="solution-toggle-2-p btn btn-default">TOGGLE SOLUTION</a>

<a name="tail" class="anchor"></a>
## Tail Recursion
Write `keep-first-n`. `keep-first-n` takes a list and a number `n` and returns a list that consists of the first `n` numbers of `n`, assuming `lst` is at least length `n`.

    scm> (keep-first-n (list 1 2 3 4 5) 3)
    (1 2 3)
    scm> (keep-first-n (list 'a 'b 'c) 1)
    (a)

<pre><code>(define (keep-first-n lst n)
<span class="solution-prompt">  "YOUR CODE HERE"
)</span>
<span class="solution-p">  (define (helper i result lst)
    (if (= i n) result
        (helper (+ i 1) (append result (list (car lst))) (cdr lst)))
    )
  (helper 0 '() lst))
)</span></code></pre>
<a class="solution-toggle-p btn btn-default">TOGGLE SOLUTION</a>&nbsp;&nbsp; <a class="btn btn-default" href="/cs61a/guides/tail-recursion.html#keep">EXPLANATION</a>

<a name="stream" class="anchor"></a>
## Streams
Write a function that creates a cyclic stream out of the first `n` elements of `lst`, or the entire `lst` if the length of `lst` is less than `n`. 
  
    scm> (cycle-first-n 3 (list 1 2 3 4))
    (1 . #[promise (not forced)])
    scm> (stream-to-list (cycle-first-n 3 (list 1 2 3 4)) 10)  ; prints stream as list
    (1 2 3 1 2 3 1 2 3 1)
    scm> (stream-to-list (cycle-first-n 7 (list 1 2 3 4)) 10)
    (1 2 3 4 1 2 3 4 1 2)

<pre><code>(define (cycle-first-n n lst)
<span class="solution-3-prompt">  "YOUR CODE HERE"
)</span>
<span class="solution-3-p">  (define (stream-helper i curr-lst)
    (if (or (zero? i) (null? curr-lst))
        (cycle-first-n n lst)
        (cons-stream (car curr-lst) (stream-helper (- i 1) (cdr curr-lst)))
    ))
  (stream-helper n lst))
)</span></code></pre>
<a class="solution-toggle-3-p btn btn-default">TOGGLE SOLUTION</a>

<a name="sql" class="anchor"></a>
## SQL
Check back later!

<!-- <pre><code>(define (cycle-first-n n lst)
<span class="solution-4-prompt">  "YOUR CODE HERE"
)</span>
<span class="solution-4-p">  (define (stream-helper i curr-lst)
    (if (or (zero? i) (null? curr-lst))
        (cycle-first-n n lst)
        (cons-stream (car curr-lst) (stream-helper (- i 1) (cdr curr-lst)))
    ))
  (stream-helper n lst))
)</span></code></pre>
<a class="solution-toggle-4-p btn btn-default">TOGGLE SOLUTION</a> -->

<a name="logic" class="anchor"></a>
## Logic
Write a fact that states that one list is a suffix of another list.
    
    (query (suffix (a b c) (a b c)))
    ; expect Success!
    (query (suffix (4 5) (1 2 3 4 5)))
    ; expect Success!
    (query (suffix (1 2) (1 2 3 4 5)))
    ; expect Failed.

<pre class="solution-5"><code>(fact (suffix ?suf ?suf))
(fact (suffix ?suf (?first . ?rest))
      (suffix ?suf ?rest))</code></pre>
<p class="solution-6">**Explanation:** Our base case takes care of the case where the two lists are the same. Our recursive case then states that for the first list to be a suffix of the second, it must be a suffix of the rest of the list. When `?rest` is assigned to a list that is the same as `?suf`, the fact becomes a `Success!`.</p>
<a class="solution-toggle-5 btn btn-default">TOGGLE SOLUTION</a> &nbsp;
<a class="solution-toggle-6 btn btn-default">TOGGLE EXPLANATION</a>
</xmp>

<script src="http://strapdownjs.com/v/0.2/strapdown.js"></script>
<link href="../../css/lumen.css" rel="stylesheet">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="../../js/bootstrap.min.js"></script>
<script src="../../js/slidin.js"></script>

<style>
.navbar .nav>li>.dropdown-menu:before, .navbar .nav>li>.dropdown-menu:after {
  margin-left: 70%;
}
</style>

</html>